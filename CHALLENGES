There are a couple of challenges with making this library successfully multi-threaded.

Static variables must go, although it is possible to make static variables thread local in GNU-C (and C11) we will probably want things like class descriptions global in shared memory, currently it's not safe to create new objects in a multi-threaded manner, there is a data race in every function which creates a new class description.
- This point should be done now, every static variable has had its access synchronized.

Exceptions need to be revised, the utility_stack is not thread safe, perhaps the solution is simple by making the exception stack thread local, but I'll need to look over this.
- Each thread now has its own exception stack, and threads get killed in a safe manner if they have no corresponding try clause.

There is no main thread object, I suppose it is possible to create a main thread object, whether such a thing is useful or not I am unsure but it would make the interface more uniform.

More to come.

Here is a test program which should work with this version.
It is an implementation of the sleepsort algorithm.

#include <stdio.h>
#include <unistd.h>

#include <coal/lang/thread.h>

void * target (int number) {
  sleep(number);
  printf("%d\n", number);
  fflush(stdout);

  return NULL;
}

int main (int argc, char ** argv) {
  int i;
  var * threads;

  threads = malloc(sizeof(var) * (argc-1));

  for (i = 0; i < argc-1; i++) {
    int number = atoi(argv[i+1]);

    threads[i] = new(thread(),
		     target,
		     number);
    thread_start(threads[i]);
  }

  /* del on a thread object
     implicitly joins with
     the thread */
  for (i = 0; i < argc-1; i++)
    del(threads[i]);

  free(threads);

  exit(EXIT_SUCCESS);
}
